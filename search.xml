<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Apache FTPClient 使用过程中遇到的坑</title>
      <link href="/2020/05/25/Apache%20FTPClient%20%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/05/25/Apache%20FTPClient%20%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Apache-FTPClient"><a href="#Apache-FTPClient" class="headerlink" title="Apache FTPClient"></a>Apache FTPClient</h2><h4 id="远端大文件复制带来的程序假死问题"><a href="#远端大文件复制带来的程序假死问题" class="headerlink" title="远端大文件复制带来的程序假死问题"></a>远端大文件复制带来的程序假死问题</h4><hr><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在进入云平台开发组一段时间后，开始撸代码了。接的第一个需求并不复杂：对自定义的ECS裸机进行配置。所谓的自定义ECS，顾名思义，用户可以自己定制该服务，并不局限于平台提供的标准服务。那么一个关键的配置项就是软件包和安装脚本。</p><p>项目接入了公司自有OSS管理平台用来管理用户自上传的脚本和软件包。OSS平台同时支持FTP配置。由于工期较紧（手动狗头），leader选择用ftp方式进行文件管理。于是引出了今天遇到的问题。</p><hr><h3 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题 &amp; 解决"></a>问题 &amp; 解决</h3><p>FTP客户端选用的是  <code>org.apache.commons.net.ftp.FTPClient</code><br>项目内搜索，有现成的工具类和方法 <code>FTPHelper.java</code>，其中我需要的上传、删除，复制都封装好了，于是心中窃喜，只要调用一下不就OK了吗。</p><p>上传，删除功能都进行的很顺利，但是复制功能始终不OK。开始debug。</p><p>先看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void copyFileToDirectory(String originalFilePathAndName, String destDir) throws UnsupportedEncodingException &#123;</span><br><span class="line">    InputStream in &#x3D; this.getInputStreamFromFTP(new String(originalFilePathAndName.getBytes(&quot;utf-8&quot;), ISO_8859_1));</span><br><span class="line">    String filePathAndName &#x3D; destDir + &quot;&#x2F;&quot;</span><br><span class="line">            + originalFilePathAndName.substring(originalFilePathAndName.lastIndexOf(&#39;&#x2F;&#39;) + 1);</span><br><span class="line">    this.writeInputStreamToFTP(new String(filePathAndName.getBytes(&quot;utf-8&quot;), ISO_8859_1), in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先根据FTP Server远程路径+文件名获取文件的输入流，再把该流写入目标路径。看起来没啥毛病。但是文件没有复制成功。debug Step Into, 发现了一处诡异的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public InputStream getInputStreamFromFTP(String pathAndName) &#123;</span><br><span class="line">        LOG.info(&quot;正在通过文件名称获取远程文件流，pathAndName&#x3D;&quot; + pathAndName + &quot; ......&quot;);</span><br><span class="line"></span><br><span class="line">        Validate.notNull(pathAndName, &quot;ftp上的文件所在所在路径和名称&quot;);</span><br><span class="line"></span><br><span class="line">        String fileName &#x3D; pathAndName.substring(pathAndName.lastIndexOf(&#39;&#x2F;&#39;) + 1);</span><br><span class="line">        String path &#x3D; pathAndName.substring(0, pathAndName.lastIndexOf(&#39;&#x2F;&#39;) + 1);</span><br><span class="line"></span><br><span class="line">        InputStream is &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            changeDirectory(path);</span><br><span class="line"></span><br><span class="line">            is &#x3D; ftpClient.retrieveFileStream(new String(fileName.getBytes(&quot;utf-8&quot;), ISO_8859_1));</span><br><span class="line"></span><br><span class="line">            if (null &#x3D;&#x3D; is) &#123;</span><br><span class="line">                throw new FileNotFoundException(fileName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOG.error(&quot;ftp通过文件名称获取远程文件流&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null !&#x3D; is) &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                    ftpClient.completePendingCommand();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                LOG.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return is;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意finally代码块中令人瞩目的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">大哥，我的流还没读取你就给我关闭了，玩呢。</span><br><span class="line"></span><br><span class="line">坑找到了，删除了这行代码，文件复制成功。</span><br><span class="line"></span><br><span class="line">然鹅事情没这么简单，测试过程中，在复制大文件时，出现了问题。</span><br><span class="line"></span><br><span class="line">程序在此处假死</span><br></pre></td></tr></table></figure><p> String line = <em>controlInput</em>.readLine();<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">继续定位问题，场景是很误导人的，较小的文件复制成功，较大的程序包复制失败。让我自然而然往性能瓶颈的方向考虑。文件较大超时了吗？文件单行读取过长？BufferSize需要增大吗？。。。</span><br><span class="line"></span><br><span class="line">无效尝试 times N</span><br><span class="line"></span><br><span class="line">Two thousands years later...</span><br><span class="line"></span><br><span class="line">我突然想到那个诡异的流关闭操作。会不会跟它有关呢？试着搜索一下，果然问题出在这里：</span><br><span class="line"></span><br><span class="line">再看一遍finally代码块：</span><br></pre></td></tr></table></figure><br>finally {<br>    try {<br>        if (null != is) {<br>            is.close();<br>            ftpClient.completePendingCommand();<br>        }<br>    } catch (IOException e) {<br>        LOG.error(e.getMessage(), e);<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**&#96;&#96;&#96;ftpClient.completePendingCommand();&#96;&#96;&#96;**</span><br></pre></td></tr></table></figure><pre><code>/*** There are a few FTPClient methods that do not complete the* entire sequence of FTP commands to complete a transaction.  These* commands require some action by the programmer after the reception* of a positive intermediate command.  After the programmer&apos;s code* completes its actions, it must call this method to receive* the completion reply from the server and verify the success of the* entire transaction.*/public boolean completePendingCommand() throws IOException{    return FTPReply.isPositiveCompletion(getReply());}</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们发现，这是一个同步阻塞方法，在上传&#x2F;下载过程中，如果获取了流，需要手动关闭该Stream， 并调用completePendingCommand()方法。如果少调用或多调用，都会导致程序阻塞假死。FTPClient无法再进行任何其他操作。在本例中，是工作路径的切换被阻塞，导致其他操作皆无反应。</span><br><span class="line"></span><br><span class="line">好了，我冤枉之前的大哥了，乖乖把删除的关闭流代码加回来。但是这样又无法读取流了。</span><br><span class="line"></span><br><span class="line">。。。。。。</span><br><span class="line"></span><br><span class="line">分析到这里，解决方案呼之欲出了。前面的大哥，你的锅还是要背。流是要关闭的，但是关闭的时序错了。如果不关闭流，FTPClient阻塞程序假死，如果关闭流，文件就读不到了，这里的</span><br><span class="line">* 方案一：深度拷贝流（不推荐）</span><br><span class="line"></span><br><span class="line">   * 修改getInputStreamFromFTP, 暂时不关闭流，暂时不调用completePendingCommand()方法；</span><br></pre></td></tr></table></figure><pre><code>    public InputStream getInputStreamFromFTP(String pathAndName) {        LOG.info(&quot;正在通过文件名称获取远程文件流，pathAndName=&quot; + pathAndName + &quot; ......&quot;);        Validate.notNull(pathAndName, &quot;ftp上的文件所在所在路径和名称&quot;);        String fileName = pathAndName.substring(pathAndName.lastIndexOf(&apos;/&apos;) + 1);        String path = pathAndName.substring(0, pathAndName.lastIndexOf(&apos;/&apos;) + 1);        InputStream is = null;        try {            changeDirectory(path);            is = ftpClient.retrieveFileStream(new String(fileName.getBytes(&quot;utf-8&quot;), ISO_8859_1));// 获取远程ftp上指定文件的InputStream            if (null == is) {                throw new FileNotFoundException(fileName);            }        } catch (Exception e) {            LOG.error(&quot;ftp通过文件名称获取远程文件流&quot;, e);        }        return is;    }    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 拷贝流方法</span><br></pre></td></tr></table></figure>    private ByteArrayOutputStream cloneInputStream(InputStream input) {        try {            ByteArrayOutputStream baos = new ByteArrayOutputStream();            byte[] buffer = new byte[1024];            int len;            while ((len = input.read(buffer)) &gt; -1) {                baos.write(buffer, 0, len);            }            baos.flush();            return baos;        } catch (IOException e) {            e.printStackTrace();            return null;        }    }    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 主流程中获取流返回后，先深拷贝，再关闭流，再call completePendingCommand(), 再进行其他FTPClient操作</span><br></pre></td></tr></table></figure>    public boolean copyFileToDir(String originalFilePathAndName, String destDir) throws IOException {        InputStream is;        String filePathAndName;        boolean result = false;        try {            is = this.getInputStreamFromFTP(new String(originalFilePathAndName.getBytes(&quot;utf-8&quot;), ISO_8859_1));            filePathAndName = destDir + &quot;/&quot;                    + originalFilePathAndName.substring(originalFilePathAndName.lastIndexOf(&apos;/&apos;) + 1);            ByteArrayOutputStream baos = cloneInputStream(is);            try {                if (null != is) {                    is.close();                    ftpClient.completePendingCommand();                }            } catch (IOException e) {                LOG.error(e.getMessage(), e);            }            if (null != baos) {                InputStream input = new ByteArrayInputStream(baos.toByteArray());                result = this.writeInputStreamToFTP(new String(filePathAndName.getBytes(&quot;utf-8&quot;), ISO_8859_1), input);                input.close();            }        } catch (IOException e) {            e.printStackTrace();            return false;        }        return result;    }    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 方案二 使用rename方法（推荐）</span><br></pre></td></tr></table></figure>/** * Renames a remote file. * &lt;p&gt; * @param from  The name of the remote file to rename. * @param to    The new name of the remote file. * @return True if successfully completed, false if not. * @exception FTPConnectionClosedException *      If the FTP server prematurely closes the connection as a result *      of the client being idle or some other reason causing the server *      to send FTP reply code 421.  This exception may be caught either *      as an IOException or independently as itself. * @exception IOException  If an I/O error occurs while either sending a *      command to the server or receiving a reply from the server. */public boolean rename(String from, String to) throws IOException{    if (!FTPReply.isPositiveIntermediate(rnfr(from))) {        return false;    }    return FTPReply.isPositiveCompletion(rnto(to));}```该方法减少了不必要的数据传输，效率明显更优。</code></pre><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这次遇到的不是什么太高深的问题，解决的过程却一波三折，花费了不少时间。</p><p>感悟就是不要轻易相信轮子，阅读源码是真的有必要。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC上传大文件需要更改哪些配置</title>
      <link href="/2020/05/25/Spring%20MVC%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%94%B9%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/05/25/Spring%20MVC%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%94%B9%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><hr><h3 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h3><hr><figure class="highlight plain"><figcaption><span>最大支持上传文件size</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;maxInMemorySize&#96;&#96;&#96; 低于此阈值则直接内存，高于此阈值则在磁盘生成临时文件</span><br><span class="line"></span><br><span class="line"> example:</span><br></pre></td></tr></table></figure><p><bean id="multipartResolver"        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"><br>        <property name="defaultEncoding" value="utf-8" /><br>        <property name="maxUploadSize" value="631242752" /><br>        <property name="maxInMemorySize" value="409600" /><br></bean></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">### Nginx配置文件</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>http {<br>    ···<br>    ···<br>    client_max_body_size 512m;<br>    ···<br>    ···<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">### wildFly 配置文件</span><br><span class="line">---</span><br><span class="line">Undertow (web) subsystem configuration - WildFly 8 - Project Documentation Editor</span><br></pre></td></tr></table></figure><subsystem xmlns="urn:jboss:domain:undertow:1.2">    ···    ···    <server name="default-server">        ···        ···        <http-listener name="default" socket-binding="http" max-post-size="631242752"/>        ···        ···    </server>    ···    ···</subsystem>```]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建</title>
      <link href="/2020/05/01/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/05/01/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的由来"><a href="#博客的由来" class="headerlink" title="博客的由来"></a>博客的由来</h2><hr><p>2020年的五一假期，我做的第一件事就是连夜购买了域名，搭建起了我的个人博客。</p><p>为什么呢？</p><p>天下苦秦久矣。</p><a id="more"></a><p>我渴望逃离996的模式，寻求一个企业文化良好、技术氛围浓厚的公司已经是公开的秘密了。这里也不多说现东家的坏话了，本身也都是当年自己的选择，抱怨是没有用的，要行动。</p><p><img src="https://cdn.img.wenhairu.com/images/2020/05/01/YYZA6.md.png" alt="YYZA6.md.png" title="出自姜文电影《邪不胜正》"><br><img src="https://cdn.img.wenhairu.com/images/2020/05/01/YY0GI.md.png" alt="YYMep.md.png" title="出自姜文电影《邪不胜正》"></p><blockquote><p>图片出自姜文电影《邪不胜正》，侵删</p></blockquote><p>那么，为什么行动就要搭建博客呢？<br>因为行动，曾经是有的，但是，是失败的行动。</p><h2 id="失败的行动"><a href="#失败的行动" class="headerlink" title="失败的行动"></a>失败的行动</h2><hr><p>过去我进行过两次面试，结果都没有成功。面试中暴露了我很多的弱点：</p><ul><li>本科并非计算机专业，基础知识有缺失</li><li>工作时间短，项目经历单一，存在技术盲区</li><li>平时对技术细节的理解思考不够深入</li><li>面试总是临时起意，没有做好充足准备</li></ul><p>平心而论，前两点并不是致命的。尽管它们是客观因素，但更大的原因还是自己平时不注意积累。一年的工作中我实际上接触了大量的技术，只是繁忙的工作让我忘记了总结和积累，有时只是会用某项技术，却没有了解细节和原理，有些不常用的技术，也会在一段时间后，印象变得模糊。</p><p>此外，我大概从半年前开始准备，过程断断续续，主要集中在对理论知识的学习和leetcode/lintcode刷题。其实学习量并不小，但是转化率并不良好，用高中老师的一句话说就是“投入产出比不高”。</p><p>我刷了大量的题，但是直到接到面试感受到压力，才有了明显提升，但是有些too late了。（最终眼高手低，阴沟翻船，倒在一个每次看见都会跳过的简单问题，细节没把握好）。</p><p>我也阅读了不少书籍和技术博客。但是由于没有计划，也没有总结，最终没有形成知识体系，遗忘的也很多。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><hr><p>于是，我终于认识到学习方法和习惯的重要性。一路以来，甚至直到Master毕业，我几乎从来没有用过科学高效的学习方法。成绩一直过的去纯属靠的脑袋不笨。但是现在作为一个后来者，这样的学习模式明显是不行了。</p><blockquote><p>The definition of insanity is doing the same thing over and over and expecting different results.</p></blockquote><blockquote><p>疯狂就是重复地做同一件事情，却期待能有不同的结果。</p></blockquote><blockquote><p>The significant problems we face cannot be solved at the same level of thinking we were at when we created them.</p></blockquote><blockquote><p>问题不可能由导致这种问题的思维方式来解决。</p></blockquote><p>以上是爱因斯坦广为流传的两句名言。爱因斯坦是不是真的说过我不知道 <del>（爱因斯坦不相信量子力学，我觉得第一句很有可能）</del>，但是确实很有道理。</p><p>所以，从现在开始，我需要</p><ul><li>制定明确的计划</li><li>要有实际的产出</li></ul><p>计划可以保证我学习的内容是均衡而成体系的，产出一来可以加深自己对学习内容的理解，潜在的读者（希望有吧）也迫使我查证不确定的细节，以免误导他人，二来也方便自己日后查阅。</p><p>于是，我认定，维护自己的技术博客，会是一个好的改变，会是一个相对正确的行动。</p><h2 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h2><hr><p>今天我 <em><strong>K</strong></em> 某人 Flag 就立在这里了，从今天开始保持学习和写作，更新频率大于 <strong>两篇/周</strong>， 内容包括并不限于</p><ul><li>Leetcode 题解和总结</li><li>操作系统、网络基础知识</li><li>后端开发套装（java Spring 数据库 分布式等等等等，视情况拆分）</li><li>设计模式</li><li>微信小程序开发教程（想法还没有呢）</li><li>工作生活中的感悟和吐槽</li></ul><p>希望在半年后我可以得到显著的提高，拿到想要offer，去过向往的生活。</p><p>这个博客是主要写给自己看的，但我也希望有一天我写的内容能够帮助到同样在学习的人。是日以技术会友，想想也是挺期待的。<del>更何况，谁还没有颗当网红的心？</del></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
