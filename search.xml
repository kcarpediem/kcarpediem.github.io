<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Apache FTPClient 使用过程中遇到的坑</title>
      <link href="/2020/05/25/Apache%20FTPClient%20%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2020/05/25/Apache%20FTPClient%20%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Apache-FTPClient"><a href="#Apache-FTPClient" class="headerlink" title="Apache FTPClient"></a>Apache FTPClient</h2><h2 id="远端大文件复制带来的程序假死问题"><a href="#远端大文件复制带来的程序假死问题" class="headerlink" title="远端大文件复制带来的程序假死问题"></a>远端大文件复制带来的程序假死问题</h2><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><hr><p>在进入云平台开发组一段时间后，开始撸代码了。接的第一个需求并不复杂：对自定义的ECS裸机进行配置。所谓的自定义ECS，顾名思义，用户可以自己定制该服务，并不局限于平台提供的标准服务。那么一个关键的配置项就是软件包和安装脚本。</p><p>项目接入了公司自有OSS管理平台用来管理用户自上传的脚本和软件包。OSS平台同时支持FTP配置。由于工期较紧（手动狗头），leader选择用ftp方式进行文件管理。于是引出了今天遇到的问题。</p><hr><h2 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题 &amp; 解决"></a>问题 &amp; 解决</h2><hr><p>FTP客户端选用的是  <code>org.apache.commons.net.ftp.FTPClient</code><br>项目内搜索，有现成的工具类和方法 <code>FTPHelper.java</code>，其中我需要的上传、删除，复制都封装好了，于是心中窃喜，只要调用一下不就OK了吗。</p><p>上传，删除功能都进行的很顺利，但是复制功能始终不OK。开始debug。</p><p>先看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFileToDirectory</span><span class="params">(String originalFilePathAndName, String destDir)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">this</span>.getInputStreamFromFTP(<span class="keyword">new</span> String(originalFilePathAndName.getBytes(<span class="string">"utf-8"</span>), ISO_8859_1));</span><br><span class="line">    String filePathAndName = destDir + <span class="string">"/"</span></span><br><span class="line">            + originalFilePathAndName.substring(originalFilePathAndName.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.writeInputStreamToFTP(<span class="keyword">new</span> String(filePathAndName.getBytes(<span class="string">"utf-8"</span>), ISO_8859_1), in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先根据FTP Server远程路径+文件名获取文件的输入流，再把该流写入目标路径。看起来没啥毛病。但是文件没有复制成功。debug Step Into, 发现了一处诡异的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStreamFromFTP</span><span class="params">(String pathAndName)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"正在通过文件名称获取远程文件流，pathAndName="</span> + pathAndName + <span class="string">" ......"</span>);</span><br><span class="line"></span><br><span class="line">        Validate.notNull(pathAndName, <span class="string">"ftp上的文件所在所在路径和名称"</span>);</span><br><span class="line"></span><br><span class="line">        String fileName = pathAndName.substring(pathAndName.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line">        String path = pathAndName.substring(<span class="number">0</span>, pathAndName.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            changeDirectory(path);</span><br><span class="line"></span><br><span class="line">            is = ftpClient.retrieveFileStream(<span class="keyword">new</span> String(fileName.getBytes(<span class="string">"utf-8"</span>), ISO_8859_1));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == is) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(fileName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"ftp通过文件名称获取远程文件流"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != is) &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                    ftpClient.completePendingCommand();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOG.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意finally代码块中令人瞩目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is.close();</span><br></pre></td></tr></table></figure><p>大哥，我的流还没读取你就给我关闭了，玩呢。</p><p>坑找到了，删除了这行代码，文件复制成功。</p><p>然鹅事情没这么简单，测试过程中，在复制大文件时，出现了问题。</p><p>程序在此处假死</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String line = _controlInput_.readLine();</span><br></pre></td></tr></table></figure><p>继续定位问题，场景是很误导人的，较小的文件复制成功，较大的程序包复制失败。让我自然而然往性能瓶颈的方向考虑。文件较大超时了吗？文件单行读取过长？BufferSize需要增大吗？。。。</p><p>无效尝试 times N</p><p>Two thousands years later…</p><p>我突然想到那个诡异的流关闭操作。会不会跟它有关呢？试着搜索一下，果然问题出在这里：</p><p>再看一遍finally代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != is) &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            ftpClient.completePendingCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOG.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftpClient.completePendingCommand();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* There are a few FTPClient methods that do not complete the</span></span><br><span class="line"><span class="comment">* entire sequence of FTP commands to complete a transaction.  These</span></span><br><span class="line"><span class="comment">* commands require some action by the programmer after the reception</span></span><br><span class="line"><span class="comment">* of a positive intermediate command.  After the programmer's code</span></span><br><span class="line"><span class="comment">* completes its actions, it must call this method to receive</span></span><br><span class="line"><span class="comment">* the completion reply from the server and verify the success of the</span></span><br><span class="line"><span class="comment">* entire transaction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completePendingCommand</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FTPReply.isPositiveCompletion(getReply());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们发现，这是一个同步阻塞方法，在上传/下载过程中，如果获取了流，需要手动关闭该Stream， 并调用completePendingCommand()方法。如果少调用或多调用，都会导致程序阻塞假死。FTPClient无法再进行任何其他操作。在本例中，是工作路径的切换被阻塞，导致其他操作皆无反应。</p><p> 好了，我冤枉之前的大哥了，乖乖把删除的关闭流代码加回来。但是这样又无法读取流了。</p><p> 。。。。。。</p><p> 分析到这里，解决方案呼之欲出了。前面的大哥，你的锅还是要背。流是要关闭的，但是关闭的时序错了。如果不关闭流，FTPClient阻塞程序假死，如果关闭流，文件就读不到了，这里的</p><ul><li><p>方案一：深度拷贝流（不推荐）</p><ul><li>修改getInputStreamFromFTP, 暂时不关闭流，暂时不调用completePendingCommand()方法；  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStreamFromFTP</span><span class="params">(String pathAndName)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"正在通过文件名称获取远程文件流，pathAndName="</span> + pathAndName + <span class="string">" ......"</span>);</span><br><span class="line"></span><br><span class="line">    Validate.notNull(pathAndName, <span class="string">"ftp上的文件所在所在路径和名称"</span>);</span><br><span class="line"></span><br><span class="line">    String fileName = pathAndName.substring(pathAndName.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line">    String path = pathAndName.substring(<span class="number">0</span>, pathAndName.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        changeDirectory(path);</span><br><span class="line"></span><br><span class="line">        is = ftpClient.retrieveFileStream(<span class="keyword">new</span> String(fileName.getBytes(<span class="string">"utf-8"</span>), ISO_8859_1));<span class="comment">// 获取远程ftp上指定文件的InputStream</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == is) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.error(<span class="string">"ftp通过文件名称获取远程文件流"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>拷贝流方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ByteArrayOutputStream <span class="title">cloneInputStream</span><span class="params">(InputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = input.read(buffer)) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        baos.flush();</span><br><span class="line">        <span class="keyword">return</span> baos;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>主流程中获取流返回后，先深拷贝，再关闭流，再call completePendingCommand(), 再进行其他FTPClient操作  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">copyFileToDir</span><span class="params">(String originalFilePathAndName, String destDir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream is;</span><br><span class="line">    String filePathAndName;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">this</span>.getInputStreamFromFTP(<span class="keyword">new</span> String(originalFilePathAndName.getBytes(<span class="string">"utf-8"</span>), ISO_8859_1));</span><br><span class="line">        filePathAndName = destDir + <span class="string">"/"</span></span><br><span class="line">                + originalFilePathAndName.substring(originalFilePathAndName.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>);</span><br><span class="line">        ByteArrayOutputStream baos = cloneInputStream(is);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != is) &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                ftpClient.completePendingCommand();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOG.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != baos) &#123;</span><br><span class="line">            InputStream input = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            result = <span class="keyword">this</span>.writeInputStreamToFTP(<span class="keyword">new</span> String(filePathAndName.getBytes(<span class="string">"utf-8"</span>), ISO_8859_1), input);</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>方案二 使用rename方法（推荐）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Renames a remote file.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from  The name of the remote file to rename.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to    The new name of the remote file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if successfully completed, false if not.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> FTPConnectionClosedException</span></span><br><span class="line"><span class="comment"> *      If the FTP server prematurely closes the connection as a result</span></span><br><span class="line"><span class="comment"> *      of the client being idle or some other reason causing the server</span></span><br><span class="line"><span class="comment"> *      to send FTP reply code 421.  This exception may be caught either</span></span><br><span class="line"><span class="comment"> *      as an IOException or independently as itself.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IOException  If an I/O error occurs while either sending a</span></span><br><span class="line"><span class="comment"> *      command to the server or receiving a reply from the server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rename</span><span class="params">(String from, String to)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!FTPReply.isPositiveIntermediate(rnfr(from))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FTPReply.isPositiveCompletion(rnto(to));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  该方法减少了不必要的数据传输，效率明显更优。</li></ul><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这次遇到的不是什么太高深的问题，解决的过程却一波三折，花费了不少时间。</p><p>感悟就是不要轻易相信轮子，阅读源码是真的有必要。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC上传大文件需要更改哪些配置</title>
      <link href="/2020/05/25/Spring%20MVC%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%94%B9%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/05/25/Spring%20MVC%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%94%B9%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><hr><h3 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxUploadSizes</span><br></pre></td></tr></table></figure><p>最大支持上传文件大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">maxInMemorySize</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">低于此阈值则直接内存，高于此阈值则在磁盘生成临时文件</span><br><span class="line"></span><br><span class="line"> example:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">&lt;bean id&#x3D;&quot;multipartResolver&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;631242752&quot; &#x2F;&gt;</span><br><span class="line">&lt;property name&#x3D;&quot;maxInMemorySize&quot; value&#x3D;&quot;409600&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ···</span><br><span class="line">    ···</span><br><span class="line">    client_max_body_size 512m;</span><br><span class="line">    ···</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="wildFly-配置文件"><a href="#wildFly-配置文件" class="headerlink" title="wildFly 配置文件"></a>wildFly 配置文件</h3><hr><p>Undertow (web) subsystem configuration - WildFly 8 - Project Documentation Editor</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">subsystem</span> <span class="attr">xmlns</span>=<span class="string">"urn:jboss:domain:undertow:1.2"</span>&gt;</span></span><br><span class="line">    ···</span><br><span class="line">    ···</span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span> <span class="attr">name</span>=<span class="string">"default-server"</span>&gt;</span></span><br><span class="line">        ···</span><br><span class="line">        ···</span><br><span class="line">        <span class="tag">&lt;<span class="name">http-listener</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">socket-binding</span>=<span class="string">"http"</span> <span class="attr">max-post-size</span>=<span class="string">"631242752"</span>/&gt;</span></span><br><span class="line">        ···</span><br><span class="line">        ···</span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    ···</span><br><span class="line">    ···</span><br><span class="line"><span class="tag">&lt;/<span class="name">subsystem</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建</title>
      <link href="/2020/05/01/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/05/01/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的由来"><a href="#博客的由来" class="headerlink" title="博客的由来"></a>博客的由来</h2><hr><p>2020年的五一假期，我做的第一件事就是连夜购买了域名，搭建起了我的个人博客。</p><p>为什么呢？</p><p>天下苦秦久矣。</p><a id="more"></a><p>我渴望逃离996的模式，寻求一个企业文化良好、技术氛围浓厚的公司已经是公开的秘密了。这里也不多说现东家的坏话了，本身也都是当年自己的选择，抱怨是没有用的，要行动。</p><p><img src="https://cdn.img.wenhairu.com/images/2020/05/01/YYZA6.md.png" alt="YYZA6.md.png" title="出自姜文电影《邪不胜正》"><br><img src="https://cdn.img.wenhairu.com/images/2020/05/01/YY0GI.md.png" alt="YYMep.md.png" title="出自姜文电影《邪不胜正》"></p><blockquote><p>图片出自姜文电影《邪不胜正》，侵删</p></blockquote><p>那么，为什么行动就要搭建博客呢？<br>因为行动，曾经是有的，但是，是失败的行动。</p><h2 id="失败的行动"><a href="#失败的行动" class="headerlink" title="失败的行动"></a>失败的行动</h2><hr><p>过去我进行过两次面试，结果都没有成功。面试中暴露了我很多的弱点：</p><ul><li>本科并非计算机专业，基础知识有缺失</li><li>工作时间短，项目经历单一，存在技术盲区</li><li>平时对技术细节的理解思考不够深入</li><li>面试总是临时起意，没有做好充足准备</li></ul><p>平心而论，前两点并不是致命的。尽管它们是客观因素，但更大的原因还是自己平时不注意积累。一年的工作中我实际上接触了大量的技术，只是繁忙的工作让我忘记了总结和积累，有时只是会用某项技术，却没有了解细节和原理，有些不常用的技术，也会在一段时间后，印象变得模糊。</p><p>此外，我大概从半年前开始准备，过程断断续续，主要集中在对理论知识的学习和leetcode/lintcode刷题。其实学习量并不小，但是转化率并不良好，用高中老师的一句话说就是“投入产出比不高”。</p><p>我刷了大量的题，但是直到接到面试感受到压力，才有了明显提升，但是有些too late了。（最终眼高手低，阴沟翻船，倒在一个每次看见都会跳过的简单问题，细节没把握好）。</p><p>我也阅读了不少书籍和技术博客。但是由于没有计划，也没有总结，最终没有形成知识体系，遗忘的也很多。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><hr><p>于是，我终于认识到学习方法和习惯的重要性。一路以来，甚至直到Master毕业，我几乎从来没有用过科学高效的学习方法。成绩一直过的去纯属靠的脑袋不笨。但是现在作为一个后来者，这样的学习模式明显是不行了。</p><blockquote><p>The definition of insanity is doing the same thing over and over and expecting different results.</p></blockquote><blockquote><p>疯狂就是重复地做同一件事情，却期待能有不同的结果。</p></blockquote><blockquote><p>The significant problems we face cannot be solved at the same level of thinking we were at when we created them.</p></blockquote><blockquote><p>问题不可能由导致这种问题的思维方式来解决。</p></blockquote><p>以上是爱因斯坦广为流传的两句名言。爱因斯坦是不是真的说过我不知道 <del>（爱因斯坦不相信量子力学，我觉得第一句很有可能）</del>，但是确实很有道理。</p><p>所以，从现在开始，我需要</p><ul><li>制定明确的计划</li><li>要有实际的产出</li></ul><p>计划可以保证我学习的内容是均衡而成体系的，产出一来可以加深自己对学习内容的理解，潜在的读者（希望有吧）也迫使我查证不确定的细节，以免误导他人，二来也方便自己日后查阅。</p><p>于是，我认定，维护自己的技术博客，会是一个好的改变，会是一个相对正确的行动。</p><h2 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h2><hr><p>今天我 <em><strong>K</strong></em> 某人 Flag 就立在这里了，从今天开始保持学习和写作，更新频率大于 <strong>两篇/周</strong>， 内容包括并不限于</p><ul><li>Leetcode 题解和总结</li><li>操作系统、网络基础知识</li><li>后端开发套装（java Spring 数据库 分布式等等等等，视情况拆分）</li><li>设计模式</li><li>微信小程序开发教程（想法还没有呢）</li><li>工作生活中的感悟和吐槽</li></ul><p>希望在半年后我可以得到显著的提高，拿到想要offer，去过向往的生活。</p><p>这个博客是主要写给自己看的，但我也希望有一天我写的内容能够帮助到同样在学习的人。是日以技术会友，想想也是挺期待的。<del>更何况，谁还没有颗当网红的心？</del></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
